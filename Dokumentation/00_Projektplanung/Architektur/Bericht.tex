\documentclass[
	ngerman,
	toc=listof, % Abbildungsverzeichnis sowie Tabellenverzeichnis in das Inhaltsverzeichnis aufnehmen
	toc=bibliography, % Literaturverzeichnis in das Inhaltsverzeichnis aufnehmen
	footnotes=multiple, % Trennen von direkt aufeinander folgenden Fußnoten
	parskip=half, % vertikalen Abstand zwischen Absätzen verwenden anstatt horizontale Einrückung von Folgeabsätzen
	numbers=noendperiod % Den letzten Punkt nach einer Nummerierung entfernen (nach DIN 5008)
]{scrartcl}
\pdfminorversion=5 % erlaubt das Einfügen von pdf-Dateien bis Version 1.7, ohne eine Fehlermeldung zu werfen (keine Garantie für fehlerfreies Einbetten!)

% Dokumenteninformationen ----------------------------------------------------
\newcommand{\titel}{Architektur}
\newcommand{\untertitel}{Studienarbeit \semester}
\newcommand{\kompletterTitel}{\titel{} \\ \untertitel}
\newcommand{\datum}{\today}

\newcommand{\vorlagenOrdner}{../../99_Vorlagen} % Falls im Unterordner ../ vorne hinzufügen

\newcommand{\betriebLogo}{\vorlagenOrdner/Bilder/logo}

% Konfiguration -------------------------------------------------------------
\input{\vorlagenOrdner/Konfiguration/Metadaten} % Metadaten zu diesem Dokument (Autor usw.)
\input{\vorlagenOrdner/Konfiguration/Packages} % verwendete Packages
\input{\vorlagenOrdner/Konfiguration/Seitenstil_Bericht} % Definitionen zum Aussehen der Seiten
\input{\vorlagenOrdner/Konfiguration/Befehle} % eigene allgemeine Befehle, die z.B. die Arbeit mit LaTeX erleichtern

\begin{document}

% Deckblatt ------------------------------------------------------------------
\phantomsection
\thispagestyle{plain}
\pdfbookmark[1]{Deckblatt}{deckblatt}
\input{\vorlagenOrdner/Konfiguration/Deckblatt}
\cleardoublepage

% Preface --------------------------------------------------------------------
\pagenumbering{Roman}

% Zweck
\section*{Zweck}
Dieses Dokument beschreibt die Architektur und liefert eine Übersicht über die Entscheidungen zum Design und der Architektur des Projektes.

% Änderungsgeschichte
\section*{Änderungsgeschichte}
\begin{tabularx}{\textwidth}{llXl}
	\toprule
	Datum & Version & Änderung & Autor \\
	\midrule
	24.03.2018 & 1.0 & Initial Setup & Janik Schlatter \\
	26.03.2020 & 1.0 & Designentscheidungen & Mike Schmid \\
	\bottomrule
\end{tabularx}
\cleardoublepage

% Inhaltsverzeichnis
\phantomsection
\pdfbookmark[1]{Inhaltsverzeichnis}{inhalt}
\tableofcontents
\cleardoublepage

\pagenumbering{arabic}
% Jede Überschrift 1 auf neuer Seite
\let\stdsection\section
\renewcommand\section{\clearpage\stdsection}

% Inhalt ---------------------------------------------------------------------
\section{Designentscheidungen}
	\subsection{Architekturentscheidungen (AE's)}
		\subsubsection{AE 1: Anwendung von Patterns für die Testerstellung}
		\begin{itemize}
			\item Im Kontext der Erweiterbarkeit des zu entwickelnden Systems,
			\item damit weitere Netzwerktest einfach hinzugefügt werden können,
			\item wurde entschieden, dass für die Testerstellung das Strategy und Factory-Method Pattern angewandt wird,
			\item um die Instanzierungslogik von den einzelnen Testklassen zu entkoppeln.
			\item Dabei wird akzeptiert, dass die Implementation des Systems alles in allem komplexer, und die Erstellung umfangreicher wird.			
		\end{itemize}

		\subsubsection{AE 2: Anwendung von Patterns für die Kommunikationsschnittstellen}
		\begin{itemize}
			\item Im Kontext der Erweiterbarkeit um weitere Netzwerkschnittstellen,
			\item damit das Hinzufügen von weiteren Schnittstellen vereinfacht wird,
			\item wurde entschieden, dass die Auswahl und Instanzierung von Verbindungen über ein Factory Method- und Strategy Pattern realisiert wird.
			\item um die Verbindungsauswahl vom System zu entkoppeln.
			\item Es wird dabei akzeptiert, dass das System komplexer wird und die Erstellung mehr Aufwand benötigt.
		\end{itemize}

		\subsubsection{AE 3: Auswahl der Testdefinitionssprache}
		\begin{itemize}
			\item Um die Testdefinitionen in einer möglichst menschenlesbaren Form zu halten,
			\item und die verwendbarkeit im zu entwickelnden System zu gewährleisten,
			\item haben wir entschieden, die Testdefinitionen in YAML zu verfassen,
			\item um ein Format zu verwenden, dass auch von Netzwerkleuten verwendet wird.
			\item Andere Technologien, wie JSON, XML usw. werden dabei voraussichtlich wegeglassen,
			\item auch wenn diese in spezifischen Anwendungen wie die Speicherung von Daten geeignet wären.
		\end{itemize}
		\newpage

		\subsubsection{AE 4: Weglassen einer Grafischen Benutzeroberfläche (GUI)}
		\begin{itemize}
			\item Im Rahmen der zeitlichen Beschränkung der Arbeit,
			\item um uns auf die Implementation der Logik zu konzentrieren,
			\item werden wir kein GUI entwickeln.
			\item Stattdessen wird, wo nötig, eine Kommandozeileninteraktion implementiert.
			\item Es wird akzeptiert, dass die Benutzerfreundlichkeit des zu entwickelnden Systems dadurch eingeschränkt wird.
		\end{itemize}

		\subsubsection{AE 5: Verwendung von Nornir}
		\begin{itemize}
			\item Für die Kommunikation mit verschiedenen Netzwerken,
			\item um die Implementation möglichst zu vereinfachen,
			\item wurde entschieden, dass das System das Nornir-Automations-Framework verwendet wird,
			\item weil Nornir komplett in Python geschrieben ist und sehr gut mit Python-Code interagiert.
		\end{itemize}

		\subsubsection{AE 6: Verzicht auf eine Datenbank}
		\begin{itemize}
			\item Um Daten persistent zu speichern, 
			\item damit sie vom System wieder abgerufen werden können,
			\item werden die Daten in form von Key-Value Paaren im YAML-Format abgelegt,
			\item und nicht in einer Datenbank,
			\item wobei ein Datenbanksystem für die zentralisierte Speicherung möglicherweise besser geeignet wäre.
		\end{itemize}
		\newpage

		\subsubsection{AE 7: Deployment als Python-Skript}
		\begin{itemize}
			\item Im Kontext des Deployments, der Auslieferung der Software,
			\item um das Programm auf möglichst vielen Plattformen einfach einsetzen zu können,
			\item wird das System in form eines Python-Scripts ausgeliefert,
			\item und nicht als ausführbare Datei im .exe Format,
			\item da Python auf den meisten Linux-Basierten Systemen und einigen modernen Windows-Systemen bereits vorinstalliert ist,
			\item womit sich die Installation/Ausführung des Programms stark vereinfacht.
			\item Die Folge, dass auf einigen Geräten für die Programmausführung zuerst Python installiert werden muss, wird akzeptiert.
		\end{itemize}

	\subsection{Umsetzungsentscheidungen}
	Ein Test nach dem anderen
	Vorerst nur eine Verbingung
	Auslagerung der automatischen Deviceerfassung
	Unittesting


\section{Systemübersicht}
	Die Systemübersicht gibt einen Überblick über die verschiedenen Komponenten des Systems. Nachfolgend sind die einzelnen Komponenten detaillierter beschrieben.\\
	\includegraphics[scale=0.7]{\vorlagenOrdner/Bilder/SystemUebersicht}

	\subsection{NUTS}
		Dies entspricht unserem Client. Er besteht aus einer Python- App die mit Hilfe von Nornir und Netconf mit dem zu testenden Netzwerk kommuniziert.

	\subsection{Netzwerk}
		Dies ist das Netzwerk des Benutzers, welches dieser gerne automatisch testen möchte.

	\subsection{Datenablage}
		Alle unsere bneötigten Daten werden mit Hilfe von YAML Files und Key-Value Stores abgespeichert. 

\section{Deployment}
	\subsection{Deploymentdiagramm}
		\includegraphics[scale=0.9]{\vorlagenOrdner/Bilder/Deploymentdiagramm}
	\subsection{Client}
		Der Client wird via PyCharm auf das Gerät des Benutzers verteilt. Später soll dies durch eine automatische Exe Datei passieren.

\section{Datenspeicherung}
	Die Datenspeicherung wird mit Hilfe von YAML Dateien und key-value Stores realisiert. Deshalb ist es nicht nötig eine Datenbank anzulegen. Die hierbei entstandenen Files werden mit Hilfe eines FileHandlers eingelesen.

\section{Ausbauszenarien}
	

\end{document}